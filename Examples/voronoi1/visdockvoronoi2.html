<!DOCTYPE html>
<meta charset="utf-8">
<link rel="stylesheet" href="visdock.css">
<style>

path {
  stroke: #fff;
}

path:first-child {
  /*fill: yellow !important;*/
}

circle {
  fill: #000;
  pointer-events: none;
}

.q0-9 { fill: rgb(197,27,125); }
.q1-9 { fill: rgb(222,119,174); }
.q2-9 { fill: rgb(241,182,218); }
.q3-9 { fill: rgb(253,224,239); }
.q4-9 { fill: rgb(247,247,247); }
.q5-9 { fill: rgb(230,245,208); }
.q6-9 { fill: rgb(184,225,134); }
.q7-9 { fill: rgb(127,188,65); }
.q8-9 { fill: rgb(77,146,33); }

</style>
<body>
<script src="http://d3js.org/d3.v3.min.js"></script>

	<script type="text/javascript" src="2D.js"></script>
	<script type="text/javascript" src="IntersectionUtilities.js"></script>

	<script type="text/javascript" src="visdock.js"></script>
	<script type="text/javascript" src="visdock.utils.js"></script>

<script>

var width = 960,
    height = 500;
    
VisDock.init("body", 1200, 800)
var viewport = VisDock.getViewport();
var svg = viewport;

var vertices = d3.range(100).map(function(d) {
  return [Math.random() * width, Math.random() * height];
});

var voronoi = d3.geom.voronoi()
    .clipExtent([[0, 0], [width, height]]);

//var svg = d3.select("body").append("svg")
//    .attr("width", width)
//    .attr("height", height)
    //.on("mousemove", function() { vertices[0] = d3.mouse(this); vertices[1][0] = vertices[1][0]+2; redraw(); });
var mouse_click = [];
var mouse_loc = [];
var circle_query = [];

var path = svg.append("g").selectAll("path");
var circ = svg.append("g").selectAll("circle");
circ = circ.data(vertices.slice(0))
circ.enter().append("circle")
    .attr("transform", function(d) { return "translate(" + d + ")"; })
    .attr("r", 1.5);

redraw();
var vertices_original = [];
for (i=0;i<vertices.length;i++){
	vertices_original[i] = [];
	vertices_original[i][0] = vertices[i][0];
	vertices_original[i][1] = vertices[i][1];
}
//var vertices_original = vertices;


function redraw() {
  path = path
      .data(voronoi(vertices), polygon);

  d3.selectAll("circle").remove();
  circ.exit().remove();

  path.exit().remove();

  circ.enter().append("circle")
    .attr("transform", function(d) { return "translate(" + d + ")"; })
    .attr("r", 1.5);

  path.enter().append("path")
      .attr("class", function(d, i) { return "q" + (i % 9) + "-9"; })
      .attr("d", polygon)
      .on("click", function(){alert("CDSKJL")});

  path.order();
  for (i=0;i<circle_query.length;i++){
  	for (k=0;k<circle_query[i].length;k++){
		var n = circle_query[i][k];
		var str_d = path[0][n].getAttributeNS(null,"d") 							
		QueryManager.layers[i][k][0][0].setAttributeNS(null,"d", str_d)
  	}
  }  
}

function polygon(d) {
  return "M" + d.join("L") + "Z";
}

VisDock.eventHandler = {
	getHitsPolygon : function(points, inclusive) {
		var hits = [];
		circle_query[num] = [];
		var shapebound = new createPolygon(points);
		for (i=0;i<path[0].length;i++){
			var captured = shapebound.intersectPath([path[0][i]], inclusive)
			if (captured.length == 1){
				hits.push(captured[0])
				circle_query[num].push(i);
			}
		}
		return hits;
		},
	getHitsLine : function(points, inclusive) {
		var shapebound = new createLine(points);
		return shapebound.intersectPath(d3.selectAll("Path")[0], inclusive)
		},
	getHitsEllipse : function(points, inclusive) {
		var shapebound = new createEllipse(points);
		return shapebound.intersectPath(d3.selectAll("Path")[0], inclusive)
	},
	setColor : function(hits) {
		//var paths = d3.selectAll("path")[0];
		for (var i = 0; i < hits.length; i++) {
			VisDock.utils.addPathLayer(hits[i], "fill: " + VisDock.color[num - 1] + "; opacity: 0.8");
			QueryManager.layers[num - 1][i][0][0].setAttributeNS(null, "id", "voronoi" + (num - 1))
		}
		//vertices[10][0]= vertices[10][0]+25;
		mouse_click[num - 1] = 0;
		d3.selectAll("#voronoi" + (num-1)).on("mousedown", function(){
			var str = this.getAttributeNS(null,"id").split("voronoi")[1];
			mouse_click[parseInt(str)] = 1;
			//alert(mouse_loc)
			if (mouse_loc[parseInt(str)] == undefined){
				
				mouse_loc[parseInt(str)] = d3.mouse(d3.selectAll("svg")[0][0]);
			} /*else {
					//mouse_loc[parseInt(str)][0] -= mouse_loc[parseInt(str)][0] - d3.mouse(d3.selectAll("svg")[0][0])[0];
				//mouse_loc[parseInt(str)][1] -= mouse_loc[parseInt(str)][1] - d3.mouse(d3.selectAll("svg")[0][0])[1];
			}*/
			})
			.on("mousemove", function(){
				var str = this.getAttributeNS(null,"id").split("voronoi")[1];
				//alert(parseInt(str))
				if (mouse_click[parseInt(str)] == 1){
					//alert("move")
					var displace_x = d3.mouse(d3.selectAll("svg")[0][0])[0] - mouse_loc[parseInt(str)][0];
					var displace_y = d3.mouse(d3.selectAll("svg")[0][0])[1] - mouse_loc[parseInt(str)][1];
				
					//d3.selectAll("#voronoi"+str).attr("transform", "translate("+displace_x + "," + displace_y +")");
					for (k=0;k<circle_query[parseInt(str)].length;k++){
						var displace_x2 = d3.mouse(d3.selectAll("svg")[0][0])[0] - vertices[k][0];
						var displace_y2 = d3.mouse(d3.selectAll("svg")[0][0])[1] - vertices[k][1];							
						var n = circle_query[parseInt(str)][k];
						vertices[n][0] = vertices_original[n][0] + displace_x;
						vertices[n][1] = vertices_original[n][1] + displace_y;
					}
					redraw();
					/*
					for (k=0;k<circle_query[parseInt(str)].length;k++){
						var n = circle_query[parseInt(str)][k];
						var str_d = path[0][n].getAttributeNS(null,"d") 							
						QueryManager.layers[parseInt(str)][k][0][0].setAttributeNS(null,"d", str_d)
					}*/					
				}
			})
			.on("mouseup", function(){
				var str = this.getAttributeNS(null,"id").split("voronoi")[1];
				//alert(d3.mouse(this)[0])
					var displace_x = d3.mouse(d3.selectAll("svg")[0][0])[0] - mouse_loc[parseInt(str)][0];
					var displace_y = d3.mouse(d3.selectAll("svg")[0][0])[1] - mouse_loc[parseInt(str)][1];
					//alert(displace_x + " akdslfjasldk " + displace_y)					
				mouse_click[parseInt(str)] = 0;
				//mouse_loc[parseInt(str)] = undefined
			})
		
		circ.data(vertices.slice(0))
		circ.remove()
		
		circ.enter().append("circle")
   			.attr("transform", function(d) { return "translate(" + d + ")"; })
   			.attr("r", 1.5);
		},
	changeColor : function(color, query, index) {
		var vis = VisDock.utils.getQueryVisibility(index);
		for (var i = 0; i < query.length; i++) {
			query[i][0][0].setAttributeNS(null, "style", "fill: " + color + "; opacity: " + vis)
		}
	},
	changeVisibility : function(vis, query, index) {
		var color = VisDock.utils.getQueryColor(index);
		for (var i = 0; i < query.length; i++) {
			query[i][0][0].setAttributeNS(null, "style", "fill: " + color + "; opacity: " + vis)
		}
	},
	removeColor : function(hits, index) {
		for (var i = 0; i < hits.length; i++) {
			//alert(hits[i])
			hits[i].remove();
		}
	},
	QueryClick : function(query, index) {
		var data = rts[index];
		var movex = mouseclick * 225 + 50;
		var margin = 25;
		var bw = (200 - margin * 2) / data.length;
		var ymax = Math.max.apply(null, data)
		var minigraph = viewport.append("g").attr("transform", "translate(" + movex + ",500)")
			minigraph.append("rect").attr("width", 200).attr("height", 200).attr("stroke", "black").attr("fill", "white")
			for (var i = 0; i < data.length; i++) {
			var h = (200 - margin * 2) * data[i] / ymax;
			var movey = margin + (200 - margin * 2 - h);
			minigraph.append("rect").attr("width", bw).attr("height", h).attr("x", (margin + i * bw)).attr("y", movey).attr("stroke", "black").attr("fill", QueryManager.colors[index]);
		}
			mouseclick++;
	}
}

</script>
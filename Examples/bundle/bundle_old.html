<!DOCTYPE html>
<meta charset="utf-8">
<link href="visdock.css" rel="stylesheet" type="text/css"/>
<style>
	text {
		font: 10px sans-serif;
	}

</style>
<body>
	<script src="http://d3js.org/d3.v3.min.js"></script>
	<script type="text/javascript" src="d3.v3.js"></script>
	<script type="text/javascript" src="visdock.js"></script>
	<script src="visdock.utils.js"></script>
	<script src="2D.js"></script>

	<script src="IntersectionUtilities.js"></script>
	<script>
		VisDock.init("body", 1200, 1000);
		// Get the VisDock viewport
		var viewport = VisDock.getViewport();
		viewport.attr("class", "chart");

		VisDock.eventHandler = {
			getHitsPolygon : function(points, inclusive) {
				var circles = d3.selectAll("circle")[0];
				var nElements = circles.length;

				var hits = [];
				var count = 0;
				var captured = 0;
				var shapebound = new createPolygon(points);
				for (var i = 0; i < nElements; i++) {
					captured = 0;
					captured = shapebound.intersectEllipse(circles[i], inclusive);
					if (captured == 1) {
						hits[count] = i;
						count++;
					}
				}
				return hits;*/
			},
			getHitsLine : function(points, inclusive) {
						var circleObjects = d3.selectAll("circle")[0];
						var nElements = circleObjects.length
						var hits = [];
						var count = 0;
						var captured = 0;

						// shapebound is a new polygon object for the polygon created by using selection tools.
						var shapebound = new createLine(points);
						for (var i = 0; i < nElements; i++) {
							captured = shapebound.intersectEllipse(circleObjects[i], inclusive);
							// captured will have 0 if the path element 'pathOjbect[i]' and the shapebound do not
							// intersect
							// Otherwise, it will have 1
							if (captured == 1) {
								// we are storing the index of the path object. But the users may
								//  choose to store other information or the object itself.
								hits[count] = i;
								count++;
							}
						}
						return hits;
			},
			getHitsEllipse : function(points, inclusive) {
						var circleObjects = d3.selectAll("circle")[0];
						var nElements = circleObjects.length
						var hits = [];
						var count = 0;
						var captured = 0;

						// shapebound is a new polygon object for the polygon created by using selection tools.
						var shapebound = new createEllipse(points);
						for (var i = 0; i < nElements; i++) {
							captured = shapebound.intersectEllipse(circleObjects[i], inclusive);
							// captured will have 0 if the path element 'pathOjbect[i]' and the shapebound do not
							// intersect
							// Otherwise, it will have 1
							if (captured == 1) {
								// we are storing the index of the path object. But the users may
								//  choose to store other information or the object itself.
								hits[count] = i;
								count++;
							}
						}
						return hits;
			},
			setColor : function(hits) {
				var circleObjects = d3.selectAll("circle")[0];
				for (var i = 0; i < hits.length; i++) {
					VisDock.utils.addEllipseLayer(circleObjects[hits[i]]);
					//var nodes = d3.selectAll(".node")[0]
					//var node = nodes[hits[i]];
					//var layers = d3.selectAll(".VisDockEllipseLayer")[0]
					//var E1 = layers[layers.length - 1];
					Panel.viewport.append("text").attr("dy", ".3em").attr("x", xx[hits[i]])
					//.style("text-anchor", "middle")
					.attr("style", "text-anchor: middle; font: 10px sans-serif;").attr("y", yy[hits[i]]).text(textbox[hits[i]]).attr("class", "VisDockText")
				}
			},
			changeColor : function(color, query, index) {
				VisDock.utils.changeQueryColor(index, color)
				var visibility = VisDock.utils.getQueryVisibility(index);
				for (var i = 0; i < query.length; i++) {
					query[i].attr("style", "opacity: " + visibility + "; fill: " + color)
				}
			},
			changeVisibility : function(vis, query, index) {
				var color = VisDock.utils.getQueryColor(index);
				for (var i = 0; i < query.length; i++) {
					query[i].attr("style", "opacity: " + vis + "; fill: " + color)
				}
			},
			removeColor : function(hits, index) {
				for (var i = 0; i < hits.length; i++) {
					//alert(hits[i])
					hits[i].remove();
				}
			}
		}

		var diameter = 960, format = d3.format(",d"), color = d3.scale.category20c();

		var bubble = d3.layout.pack().sort(null).size([diameter, diameter]).padding(1.5);

		//var svg = d3.select("body").append("svg")
		//    .attr("width", diameter)
		//    .attr("height", diameter)
		//    .attr("class", "bubble");
		var xx = [];
		var yy = [];
		var textbox = [];
		d3.json("flare.json", function(error, root) {
			var node = viewport.selectAll(".node").data(bubble.nodes(classes(root)).filter(function(d) {
				return !d.children;
			})).enter().append("g").attr("class", "node")

			//.attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; });

			//alert(node)
			node.append("title").text(function(d) {
				return d.className + ": " + format(d.value);
			});

			node.append("circle").attr("r", function(d) {
				return d.r;
			}).attr("cx", function(d) {
				return parseInt(d.x)
			}).attr("cy", function(d) {
				return parseInt(d.y)
			}).style("fill", function(d) {
				return color(d.packageName);
			});

			node.append("text").attr("dy", ".3em").attr("x", function(d) {
				xx.push(parseInt(d.x))
				return parseInt(d.x)
			}).attr("y", function(d) {
				yy.push(parseInt(d.y))
				return parseInt(d.y)
			}).style("text-anchor", "middle").text(function(d) {
				textbox.push(d.className.substring(0, d.r / 3))
				return d.className.substring(0, d.r / 3);
			});

			var aa = document.getElementsByTagName("circle")
			var bb = document.getElementsByTagName("text")

		});

		// Returns a flattened hierarchy containing all leaf nodes under the root.
		function classes(root) {
			var classes = [];

			function recurse(name, node) {
				if (node.children)
					node.children.forEach(function(child) {
						recurse(node.name, child);
					});
				else
					classes.push({
						packageName : name,
						className : node.name,
						value : node.size
					});
			}

			recurse(null, root);
			return {
				children : classes
			};
		}

		//var jj = bubble.nodes(classes(root));
		//alert(" hi = " +jj);
		d3.select(self.frameElement).style("height", diameter + "px");

		//var aa = document.getElementsByID("viewport")
		//alert(aa)
		//alert("JDFS");
		//alert(aa[10].getAttributeNS(null,"cx"));

	</script>

<!DOCTYPE html>
<meta charset="utf-8">
<link href="visdock.css" rel="stylesheet" type="text/css"/>
<style>
	.states {
		fill: none;
		stroke: #fff;
		stroke-linejoin: round;
	}

	.q0-9 {
		fill: rgb(247,251,255);
	}
	.q1-9 {
		fill: rgb(222,235,247);
	}
	.q2-9 {
		fill: rgb(198,219,239);
	}
	.q3-9 {
		fill: rgb(158,202,225);
	}
	.q4-9 {
		fill: rgb(107,174,214);
	}
	.q5-9 {
		fill: rgb(66,146,198);
	}
	.q6-9 {
		fill: rgb(33,113,181);
	}
	.q7-9 {
		fill: rgb(8,81,156);
	}
	.q8-9 {
		fill: rgb(8,48,107);
	}

</style>
<body>
	<script src="http://d3js.org/d3.v3.min.js"></script>
	<script src="http://d3js.org/queue.v1.min.js"></script>
	<script src="http://d3js.org/topojson.v0.min.js"></script>
	<script type="text/javascript" src="visdock.js"></script>
	<script type="text/javascript" src="2D.js"></script>
	<script src="IntersectionUtilities.js"></script>
	<script src="visdock.utils.js"></script>

	<script>
		width = 1100;
		height = 700;
		
		VisDock.init("body", width, height);
		VisDock.SelectShape = "circle"
		VisDock.opacity = 0.8;

		var Width = 1100;
		var Height = 700;
		var side_x = 200;
		var side_y = 127.2727272727;
		var ratio_x = side_x / Width;
		var ratio_y = side_y / Height;		
		// Get the VisDock viewport
		var viewport = VisDock.getViewport();
		viewport.attr("class", "chart");

		var c = 0;
		var mouseclick = 0;
		var rts = [];
		VisDock.eventHandler = {
			getHitsPolygon : function(points, inclusive) {
				var xx = [];
				var yy = [];
				for (var i = 0; i < points.length; i++) {
					xx[i] = points[i][0];
					yy[i] = points[i][1];
				}

				var xmax = Math.max.apply(null, xx)
				var xmin = Math.min.apply(null, xx)
				var ymax = Math.max.apply(null, yy)
				var ymin = Math.min.apply(null, yy)

				var paths = d3.selectAll("path")[0];
				var nElements = paths.length;
				var hits = [];
				var count = 0;
				var captured = 0;
				
				var shapebound = new createPolygon(points);
				rts[num] = [];

				for (var i = 0; i < nElements; i++) {

					var str = paths[i].getAttributeNS(null, "d").split("L")
					var str2 = str[0].split(",");
					var x = str2[0].split("M")[1];
					var y = str2[1];

					captured = 0;
					if (x >= xmin && x <= xmax && y >= ymin && y <= ymax) {

						captured = shapebound.intersectPath(paths[i], inclusive);
					}
					if (captured == 1) {
						var cl = paths[i].getAttributeNS(null,"class").split("-")[0];
						var r = cl.split("q")[1];
						rts[num][count] = parseInt(r);

						hits[count] = i;
						count++;
					}

				}
				//alert(rts[0])
				return hits;
			},
			getHitsLine : function(points, inclusive) {

				var xx = [];
				var yy = [];
				for (var i = 0; i < points.length; i++) {
					xx[i] = points[i][0];
					yy[i] = points[i][1];
				}

				var xmax = Math.max.apply(null, xx)
				var xmin = Math.min.apply(null, xx)
				var ymax = Math.max.apply(null, yy)
				var ymin = Math.min.apply(null, yy)

				var paths = d3.selectAll("path")[0];
				var nElements = paths.length;
				var hits = [];
				var count = 0;
				var captured = 0;
				rts[num] = [];
				var shapebound = new createLine(points)
				for (var i = 0; i < nElements; i++) {

					var str = paths[i].getAttributeNS(null, "d").split("L")
					var str2 = str[0].split(",");
					var x = str2[0].split("M")[1];
					var y = str2[1];

					captured = 0;

					if (x >= xmin && x <= xmax && y >= ymin && y <= ymax) {
						captured = shapebound.intersectPath(paths[i], inclusive);
					}
					//alert("SDJFKL");
					if (captured == 1) {
						var cl = paths[i].getAttributeNS(null,"class").split("-")[0];
						var r = cl.split("q")[1];
						rts[num][count] = parseInt(r);
						hits[count] = i;
						count++;
					}
				}
				return hits;
			},
			getHitsEllipse : function(points, inclusive) {

				var xmax = points[0] + points[2];
				//Math.max.apply(null,xx)
				var xmin = points[0] - points[2];
				//Math.min.apply(null,xx)
				var ymax = points[1] + points[3];
				//Math.max.apply(null,yy)
				var ymin = points[1] - points[3];
				//Math.min.apply(null,yy)

				var paths = d3.selectAll("path")[0];
				var nElements = paths.length;
				//var aa2 = getNodes(nElements);

				var hits = [];
				var count = 0;
				var captured = 0;
				var shapebound = new createEllipse(points);
				rts[num] = [];
				//var shapebound = PolygonInit(points);;
				for (var i = 0; i < nElements; i++) {

					var str = paths[i].getAttributeNS(null, "d").split("L")
					var str2 = str[0].split(",");
					var x = str2[0].split("M")[1];
					var y = str2[1];

					captured = 0;
					//alert("here " + ellipse);
					if (x >= xmin && x <= xmax && y >= ymin && y <= ymax) {//alert(aa[i].getAttributeNS(null,"externalResourcesRequired"))
						if (paths[i].getAttributeNS(null, "id") == "mini") {"dont"
						}
						captured = shapebound.intersectPath(paths[i], inclusive);
						//alert(aa[i])
					}

					if (captured == 1) {
						var cl = paths[i].getAttributeNS(null,"class").split("-")[0];
						var rs = cl.split("q")[1];
						rts[num][count] = parseInt(rs);
						//alert(rts)
						hits[count] = i;
						count++;
					}
				}

				return hits;
			},
			setColor : function(hits) {
				var paths = d3.selectAll("path")[0];
				for (var i=0;i<hits.length;i++){
	    			VisDock.utils.addPathLayer(paths[hits[i]], 
	    				"fill: " + VisDock.color[num - 1] + "; opacity: 0.5");
				}
			},
			changeColor : function(color, query, index) {
    			var vis = VisDock.utils.getQueryVisibility(index);
				for (var i=0;i<query.length;i++){
	    			query[i][0][0].setAttributeNS(null, "style", "fill: " + color + "; opacity: " + vis)
				}
			},
			changeVisibility : function(vis, query, index) {
    			var color = VisDock.utils.getQueryColor(index);
				for (var i=0;i<query.length;i++){
	    			query[i][0][0].setAttributeNS(null, "style", "fill: " + color + "; opacity: " + vis)
				}
			},
			removeColor : function(hits, index) {
				for (var i = 0; i < hits.length; i++) {
					//alert(hits[i])
					hits[i].remove();
				}
			},
			QueryClick : function(query, index) {
				/*	var data = rts[index];
				var movex = mouseclick*225+50;
				var margin = 25;
				var bw = (200-margin*2)/data.length;
				var ymax = Math.max.apply(null,data)
				var minigraph = viewport.append("g")
				.attr("transform","translate("+movex+",500)")

				minigraph.append("rect")
				.attr("width",200).attr("height",200)
				.attr("stroke","black")
				.attr("fill","white")

				for (var i=0;i<data.length;i++){
				var h = (200-margin*2)*data[i]/ymax;
				var movey = margin+(200-margin*2-h);
				minigraph.append("rect")
				.attr("width", bw)
				.attr("height", h)
				.attr("x",(margin+i*bw))
				.attr("y",movey)
				.attr("stroke","black")
				.attr("fill",QueryManager.colors[index]);
				}

				mouseclick++; */
				//alert("bY")
			}
		}






		var width = 960, height = 500;

		var quantize = d3.scale.quantize().domain([0, .15]).range(d3.range(9).map(function(i) {
			return "q" + i + "-9";
		}));

		var path = d3.geo.path();

		//alert("hi");
		var txtFile = new XMLHttpRequest();
		txtFile.open('GET', 'sources2.txt', false);
		//alert("hi2");
		txtFile.onreadystatechange = function() {
			allText = txtFile.responseText;
			allTextLines = txtFile.responseText.split("\r\n");
		}
		txtFile.send();
		var id = [];
		var rates = [];
		for (var i = 0; i < allTextLines.length - 1; i++) {

			var subline = allTextLines[i].split("\t");
			id[i] = subline[0];
			rates[i] = subline[1];
			//alert(subline[1])
		}

		queue().defer(d3.json, "us.json").defer(d3.tsv, "unemployment.tsv").await(ready);

		function ready(error, us, unemployment) {

			var rateById = {};
			for (var i = 0; i < rates.length; i++) {
				rateById[id[i]] = rates[i];
			}

			var svgobj = viewport.append("g").attr("id", "counties").attr("externalResourcesRequired", true).selectAll("path").data(topojson.object(us, us.objects.counties).geometries).enter().append("path").attr("class", function(d) {
				return quantize(rateById[d.id]);
			}).attr("d", path);

			var svgobj2 = VisDock.birdtemp.append("g")
				.attr("id", "counties").attr("externalResourcesRequired", true).selectAll("path").data(topojson.object(us, us.objects.counties).geometries).enter().append("path").attr("class", function(d) {
				return quantize(rateById[d.id]);
			}).attr("d", path)
			.attr("transform", "scale(" + ratio_x + "," + ratio_y + ")");

			var h = width / height * dockWidth;
			var ratio = dockWidth / width;






var bird_coor;
var bird_coor2;
var str = VisDock.birdtemp.attr("transform").split("(")[1]
var trans = str.split(")")[0];
var trans_x = trans.split(",")[0];
var trans_y = trans.split(",")[1];

//var side_x = (width - dockWidth) * ratio;
//var side_y = height * ratio;

function birdzoom(evt) {

		if (evt.preventDefault)
			evt.preventDefault();
		evt.returnValue = false;

		// Now determine the amount of zoom
		var delta;
		if (evt.wheelDelta)
			delta = evt.wheelDelta / 360;
		// Chrome/Safari
		else
			delta = evt.detail / -9;
		// Mozilla

		// @@@ Still need to determine exact mouse position wrt viewport!
		Panel.zoom(evt.clientX - 8, evt.clientY - 8, delta);
		var scale = Panel.scale;

		var x = -Panel.x*ratio// + 200*ratio_x//* Panel.scale;
		var y = -Panel.y*ratio// + 200*ratio_y//* Panel.scale;
		
		if (x < 0) {
			x = 0;
		}
		if (y < 0) {
			y = 0;
		}
		
		birdframe.attr("x", x)
			.attr("y", y)
			.attr("width", function() {
				if (x + 1 / scale * side_x > Width * ratio_x) {
					return (Width * ratio_x - x)
				} else {
					return (1/scale * side_x)
				}
				})
			.attr("height", function() {
				//alert (y + scale * side_y + " " + height * ratio)
				if (y + 1 / scale * side_y > height * ratio_y) {
					
					return (Height * ratio_y - y)
				} else {
					
					return (1/scale * side_y)
				}
				})	
}

var birdframe = VisDock.birdtemp.append("rect")
	.attr("width", side_x)
	.attr("height", side_y)
	.attr("style", "stroke:red; stroke-width:5; fill: white; opacity: 0.5")
birdframe.on("mousemove", function() {
	window.addEventListener("mousewheel", birdzoom, false);
})
birdframe.on("mousedown", function() {
	if (bird_coor == null)	bird_coor = d3.mouse(this)
	
	birdframe.on("zoom", function() {
		alert(d3.event.translate)
	})
	birdframe.on("mousemove", function() {
		var scale = Panel.scale;

		var x = this.getAttributeNS(null, "x")//* Panel.scale;
		var y = this.getAttributeNS(null, "y")//Panel.y*ratio + 200*ratio//* Panel.scale;

		bird_coor2 = d3.mouse(this);
		if (bird_coor2[0] - bird_coor[0] > 0){
			birdframe.attr("x", bird_coor2[0] - bird_coor[0])
			if (birdframe.attr("width") < 1 / Panel.scale * side_x) {
				birdframe.attr("width", 1 / Panel.scale * side_x + (bird_coor2[0] - bird_coor[0]))
			}
			if (parseFloat(birdframe.attr("x")) + parseFloat(birdframe.attr("width")) > ratio_x * (Width)) {
				//alert(birdframe.attr("x") + birdframe.attr("width") + " " +ratio * (width+dockWidth))
				var W = parseFloat(birdframe.attr("width"))
				birdframe.attr("width", W - (parseFloat(birdframe.attr("x"))
				 + parseFloat(birdframe.attr("width")) - ratio_x * Width))
			}
		} else {
			birdframe.attr("x", 0)
			//alert("JFDSKL")
			birdframe.attr("width", 1 / Panel.scale * side_x + (bird_coor2[0] - bird_coor[0]))
		}		
		
		if (bird_coor2[1] - bird_coor[1] > 0){
			birdframe.attr("y", bird_coor2[1] - bird_coor[1])
			if (birdframe.attr("height") < 1 / Panel.scale * side_y) {
				birdframe.attr("height", 1 / Panel.scale * side_y + (bird_coor2[1] - bird_coor[1]))
			}
			if (parseFloat(birdframe.attr("y")) + parseFloat(birdframe.attr("height")) > ratio_y * (Height)) {
				//alert(birdframe.attr("x") + birdframe.attr("width") + " " +ratio * (width+dockWidth))
				var H = parseFloat(birdframe.attr("height"))
				birdframe.attr("height", H - (parseFloat(birdframe.attr("y"))
				 + parseFloat(birdframe.attr("height")) - ratio_y * Height))
			}
		} else {
			birdframe.attr("y", 0)
			//alert("JFDSKL")
			birdframe.attr("height", 1 / Panel.scale * side_y + (bird_coor2[1] - bird_coor[1]))
		}		

		Panel.x = -(bird_coor2[0]-bird_coor[0])*1/ratio_x;
		Panel.y = -(bird_coor2[1]-bird_coor[1])*1/ratio_y;
		Panel.setTransform()
		})
	birdframe.on("mouseup", function() {
		bird_coor2 = [0,0];//bird_coor;
		birdframe.on("mousemove", null)
	})
})

		}

	</script>

<!DOCTYPE html>
<meta charset="utf-8">
<link href="visdock.css" rel="stylesheet" type="text/css"/>
<title>Quadtree</title>
<style>

.point {
  fill: #999;
  stroke: #fff;
}

.point.scanned {
  fill: orange;
  fill-opacity: 1;
  stroke: brown;
}

.point.selected {
  fill: red;
  fill-opacity: 1;
}

.node {
  fill: none;
  stroke: #ccc;
  shape-rendering: crispEdges;
}

.brush .extent {
  stroke: #fff;
  fill-opacity: .125;
  shape-rendering: crispEdges;
}

</style>
<body>

<script src="http://d3js.org/d3.v3.min.js"></script>
<script type="text/javascript" src="visdock.js"></script>
<script src="2D.js"></script>
<script src="IntersectionUtilities.js"></script>
<script src="visdock.utils.js"></script>
<script>

var width = 960,
    height = 500;

var data = d3.range(5000).map(function() {
  return [Math.random() * width, Math.random() * height];
});

VisDock.init("body", 1200, 1400);
var viewport = VisDock.getViewport();

var quadtree = d3.geom.quadtree()
    .extent([[-1, -1], [width + 1, height + 1]])
    (data);

var brush = d3.svg.brush()
    .x(d3.scale.identity().domain([0, width]))
    .y(d3.scale.identity().domain([0, 800]))
    .extent([[100, 100], [200, 200]])
    .on("brush", brushed);

/*var svg = d3.select("body").append("svg")
    .attr("width", width)
    .attr("height", height);*/
var svg = viewport;   
var rectangles_query = [];
var circle_query = [];
var shape_query = [];
var mouse_loc = [];
var shapes = [];

svg.selectAll(".node")
    .data(nodes(quadtree))
  .enter().append("rect")
    .attr("class", "node")
    //.attr("id", function(d) {})
    .attr("x", function(d) { //var nodes = nodes(d);
    	 return d.x; })
    .attr("y", function(d) { //var nodes = nodes(d);
    	 return d.y; })
    .attr("width", function(d) { //var nodes = nodes(d);
    	 return d.width; })
    .attr("height", function(d) { //var nodes = nodes(d);
    	 return d.height; });

var point = svg.selectAll(".point")
    .data(data)
  .enter().append("circle")
    .attr("class", "point")
    .attr("cx", function(d) { return d[0]; })
    .attr("cy", function(d) { return d[1]; })
    .attr("r", 4);

svg.append("g")
    .attr("class", "brush")
    .call(brush);

brushed();

function minmax(points){
	var x_min = y_min = 100000;
	var x_max = y_max = 0;
			
	for (var i = 0; i < points.length; i++){
		if (points[i][0] > x_max) x_max = points[i][0];
		if (points[i][0] < x_min) x_min = points[i][0]
		if (points[i][1] > y_max) y_max = points[i][1]
		if (points[i][1] < y_min) y_min = points[i][1]
	}
	return [x_min, x_max, y_min, y_max]	
}

	VisDock.eventHandler = {
		getHitsPolygon : function(points, inclusive) {
			var shapebound = new createPolygon(points);
			var lims = minmax(points)
			var circles = d3.selectAll("circle")[0]
			if (circle_query[num] == undefined) circle_query[num] = [];
			//mouse_loc[num] = []
			var hits = [];
			for (var i = 0; i < circles.length; i++){
				var x = parseInt(circles[i].getAttributeNS(null, "cx"))
				var y = parseInt(circles[i].getAttributeNS(null, "cy"))
				var r = parseInt(circles[i].getAttributeNS(null, "r"))
				if (x + 2*r >= lims[0] && x - 2*r <= lims[1] && y + 2*r >= lims[2] && y - 2*r <= lims[3]){
					var captured = shapebound.intersectEllipse([circles[i]], inclusive)
					if (captured.length == 1){
						circle_query[num].push(i)
						hits.push(captured[0])
					}
				}
			}
			createShapes(points, "rect", inclusive)
			return hits;

		},
		getHitsLine : function(points, inclusive) {
			var shapebound = new createLine(points);
			return shapebound.intersectPath(d3.selectAll("Path")[0], inclusive)

		},
		getHitsEllipse : function(points, inclusive) {
			var shapebound = new createEllipse(points);
			var lims = minmax([[points[0]-points[3], points[1]-points[3]], [points[0]+points[3], points[1]-points[3]],
				[points[0]-points[3], points[1]+points[3]], [points[0]+points[3], points[1]+points[3]]])
			var circles = d3.selectAll("circle")[0]
			if (circle_query[num] == undefined) circle_query[num] = [];
			//mouse_loc[num] = []
			var hits = [];
			for (var i = 0; i < circles.length; i++){
				var x = parseInt(circles[i].getAttributeNS(null, "cx"))
				var y = parseInt(circles[i].getAttributeNS(null, "cy"))
				var r = parseInt(circles[i].getAttributeNS(null, "r"))
				if (x + 2*r >= lims[0] && x - 2*r <= lims[1] && y + 2*r >= lims[2] && y - 2*r <= lims[3]){
					var captured = shapebound.intersectEllipse([circles[i]], inclusive)
					if (captured.length == 1){
						circle_query[num].push(i)
						hits.push(captured[0])
					}
				}
			}
			createShapes(points, "ellipse", inclusive)
			return hits;			
			//return shapebound.intersectPath(d3.selectAll("Path")[0], inclusive)
		},
		setColor : function(hits) {
			//var paths = d3.selectAll("path")[0];
			//for (var i = 0; i < hits.length; i++) {
				//VisDock.utils.addCircleLayer(hits[i], "fill: none; stroke: " + VisDock.color[num-1])
				//var sw = parseInt(maxDepth + 1 - branches[line_query[num-1][i]].d) + 'px'
				//VisDock.utils.addPolygonLayer(hits[i], "stroke: "+ VisDock.color[num - 1] + "; stroke-width:" + sw+"; opacity: 1");
			//}
			var n = circle_query[num-1];
			var circles = d3.selectAll("circle")[0];
			for (var i = 0; i < n.length; i++){
				VisDock.utils.addEllipseLayer(circles[n[i]], "fill: "+VisDock.color[num-1] + 
					";stroke: black; stroke-width: 1px; pointer-events: none", num-1)
			}
			
		},
		changeColor : function(color, query, index) {
			var vis = VisDock.utils.getQueryVisibility(index);
			for (var i = 0; i < query.length; i++) {
				query[i][0][0].setAttributeNS(null, "style", "fill: " + color + "; opacity: " + vis)
			}
		},
		changeVisibility : function(vis, query) {
			var color = VisDock.utils.getQueryColor(index);
			for (var i = 0; i < query.length; i++) {
				query[i][0][0].setAttributeNS(null, "style", "fill: " + color + "; opacity: " + vis)
			}
		},
		removeColor : function(hits, index) {
			for (var i = 0; i < hits.length; i++) {
				//alert(hits[i])
				hits[i].remove();
			}
		},
		QueryClick : function(query, index) {

		}
	}

function createShapes(p, type, inclusive){
	var p0 = [];
	var mouse_click = 0;
	var old_loc;
	if (type == "rect"){
		for (var i = 0; i < p.length; i++){
			p0[i] = [];
			p0[i][0] = p[i][0];
			p0[i][1] = p[i][1];
		}
		var shape = Panel.viewport.append("polygon")
			.attr("points", p)
			.attr("id", num)
			.attr("class", "shape")
        .style({
            "fill": "#69f",
            "fill-opacity": "0.3",
            "stroke": "white",
            "stroke-width": "1px"
        })	

	}
	else if (type == "polygon"){
		for (var i = 0; i < p.length; i++){
			p0[i] = [];
			p0[i][0] = p[i][0];
			p0[i][1] = p[i][1];
		}		
		var shape = Panel.viewport.append(type)
			.attr("points", p)
			.attr("id", num)
			.attr("class", "shape")			
        .style({
            "fill": "#69f",
            "fill-opacity": "0.3"
        });			
	}
	else if (type == "ellipse"){
		//for (var i = 0; i < p.length; i++){
		p0[0] = p[0];
		p0[1] = p[1];
		p0[2] = p[2];
		p0[3] = p[3];
		//}		
		var shape = Panel.viewport.append(type)
			.attr("cx", p[0])
			.attr("cy", p[1])
			.attr("rx", p[2])
			.attr("ry", p[3])	
			//.attr("points", points)
			.attr("id", num)
			.attr("class", "shape")			
        .style({
            "fill": "#69f",
            "fill-opacity": "0.3"
        });			
	}
	shapes.push(shape)	
	shape.on("mousedown", function(){
        	var str = this.getAttributeNS(null, "id") 
        	var s = this.tagName;
        	mouse_click = 1;
        	if (mouse_loc[parseInt(str)] == undefined){
        		mouse_loc[parseInt(str)] = d3.mouse(d3.selectAll("svg")[0][0])
        	}
        	this.setAttributeNS(null, "pointer-events", "none")
        	d3.selectAll("svg").on("mousemove", function(){
        		if (mouse_click){
        			var new_loc = d3.mouse(d3.selectAll("svg")[0][0])
        			var displacex = new_loc[0] - mouse_loc[parseInt(str)][0];
        			var displacey = new_loc[1] - mouse_loc[parseInt(str)][1];
			
        			shapes[parseInt(str)][0][0].setAttributeNS(null, "transform", "translate(" + displacex + ", " + displacey + ")")
        			refresh(displacex, displacey, parseInt(str), p, shapes[parseInt(str)][0][0], inclusive)
					if (s == "polygon"){
        				for (var i = 0; i < p.length; i++){
							p[i][0] = p0[i][0];
							p[i][1] = p0[i][1];
						}
					} else if (s == "ellipse"){
        				for (var i = 0; i < p.length; i++){
							p[i] = p0[i];
						}
					}
				}
        	})
        	d3.selectAll("svg").on("mouseup", function(){
        		mouse_click = 0;
        		shapes[parseInt(str)][0][0].setAttributeNS(null, "pointer-events", "visiblePainted")
        		//d3.selectAll("svg").on("mousemove", function()
        	})
        	
        })
        /*.on("mousemove", function(){
        	var str = this.getAttributeNS(null, "id") 
        	if (mouse_click){
        		var new_loc = d3.mouse(d3.selectAll("svg")[0][0])
        		var displacex = new_loc[0] - mouse_loc[parseInt(str)][0];
        		var displacey = new_loc[1] - mouse_loc[parseInt(str)][1];
			
        		this.setAttributeNS(null, "transform", "translate(" + displacex + ", " + displacey + ")")
        		refresh(displacex, displacey, parseInt(str), p, this, inclusive)
				
        		for (var i = 0; i < p.length; i++){
					p[i][0] = p0[i][0];
					p[i][1] = p0[i][1];
				}
        	}
        	
        	
        })*/
        //.on("mouseup", function(){ mouse_click = 0;})	
}

function refresh(displacex, displacey, index, p, shape, inclusive){
	//var str = shape.getAttributeNS(null, "transform").split("(")[1];
	//var coor = str.split(")")[0].split(",")
	/*if (previous.length == 0) {
		previous[0] = 0;
		previous[1] = 0;
	}*/
	for (var i = 0; i < QueryManager.layers[index].length; i++){
		QueryManager.layers[index][i].remove();
	}
	if (shape.tagName == "polygon"){
		for (var i = 0; i < p.length; i++){
			p[i][0] = p[i][0] + displacex //- previous[0];
			p[i][1] = p[i][1] + displacey //- previous[1];
		}
		var bound = new createPolygon(p);
		var lims = minmax(p)
		var circles = d3.selectAll("circle")[0]
		
		var hits = [];
		for (var i = 0; i < circles.length; i++){
			var x = parseInt(circles[i].getAttributeNS(null, "cx"))
			var y = parseInt(circles[i].getAttributeNS(null, "cy"))
			var r = parseInt(circles[i].getAttributeNS(null, "r"))			
			if (x + 2*r >= lims[0] && x - 2*r <= lims[1] && y + 2*r >= lims[2] && y - 2*r <= lims[3]){
				var captured = bound.intersectEllipse([circles[i]], true)
				if (captured.length == 1){
				//circle_query[num].push(i)
					hits.push(captured[0])
				}
			}
		}		
		for (var i = 0; i < hits.length; i++){
			VisDock.utils.addEllipseLayer(hits[i], "fill: "+VisDock.color[index] + 
				";stroke: black; stroke-width: 1px; pointer-events: none", index)
		}
	} else if (shape.tagName == "ellipse"){
		p[0] = p[0] + displacex //- previous[0];
		p[1] = p[1] + displacey //- previous[1];

		var bound = new createEllipse(p);
		var lims = minmax([[p[0]-p[3], p[1]-p[3]], [p[0]+p[3], p[1]-p[3]],
			[p[0]-p[3], p[1]+p[3]], [p[0]+p[3], p[1]+p[3]]])
		
		var circles = d3.selectAll("circle")[0]
		
		var hits = [];
		for (var i = 0; i < circles.length; i++){
			var x = parseInt(circles[i].getAttributeNS(null, "cx"))
			var y = parseInt(circles[i].getAttributeNS(null, "cy"))
			var r = parseInt(circles[i].getAttributeNS(null, "r"))			
			if (x + 2*r >= lims[0] && x - 2*r <= lims[1] && y + 2*r >= lims[2] && y - 2*r <= lims[3]){
				var captured = bound.intersectEllipse([circles[i]], true)
				if (captured.length == 1){
				//circle_query[num].push(i)
					hits.push(captured[0])
				}
			}
		}		
		for (var i = 0; i < hits.length; i++){
			VisDock.utils.addEllipseLayer(hits[i], "fill: "+VisDock.color[index] + 
				";stroke: black; stroke-width: 1px; pointer-events: none", index)
		}

	}
	//previous[0] = displacex - previous[0];
	//previous[1] = displacey - previous[1];
	//QueryManager.layers[index].remove();
}


function brushed() {
  var extent = brush.extent();
  point.each(function(d) { d.scanned = d.selected = false; });
  search(quadtree, extent[0][0], extent[0][1], extent[1][0], extent[1][1]);
  point.classed("selected", function(d) { return d.selected; });
  point.classed("scanned", function(d) { return d.scanned; });
}

// Collapse the quadtree into an array of rectangles.
function nodes(quadtree) {
  var nodes = [];
  quadtree.visit(function(node, x1, y1, x2, y2, x3, y3) {
  	
    nodes.push({x: x1, y: y1, width: x2 - x1, height: y2 - y1, leaf: node.leaf, cx: x3, cy: y3});
  });
  return nodes;
}

// Find the nodes within the specified rectangle.
function search(quadtree, x0, y0, x3, y3) {
  quadtree.visit(function(node, x1, y1, x2, y2) {
    var p = node.point;
    if (p) {
      p.scanned = true;
      p.selected = (p[0] >= x0) && (p[0] < x3) && (p[1] >= y0) && (p[1] < y3);
    }
    return x1 >= x3 || y1 >= y3 || x2 < x0 || y2 < y0;
  });
}

</script>
<!DOCTYPE html>
<meta charset="utf-8">
<link rel="stylesheet" href="visdock.css">
<title>Transform Transitions</title>
<style>

body {
  margin: 0;
}

.pixel {
  stroke: #fff;
  stroke-width: .1px;
}

#none {
	stroke: #fff;
	stroke-width: .1px;
}

</style>
<body>
<div id = "none">
	<button onclick = "Transform()">Transform</button>
</div>
<!--<div class = "buttons">
	
</div>-->	
<script src="http://d3js.org/d3.v3.min.js"></script>


<script type="text/javascript" src="2D.js"></script>
<script type="text/javascript" src="IntersectionUtilities.js"></script>

<script type="text/javascript" src="visdock.js"></script>
<script type="text/javascript" src="visdock.utils.js"></script>
<script>

var w = 960,
    h = 500,
    z = 20,
    x = w / z,
    y = h / z;
    
VisDock.init("body", 1200, 750);
var viewport = VisDock.getViewport();
var rect_query = [];
//var svg = d3.select("body").append("svg")
//    .attr("width", w)
//    .attr("height", h);
var svg = viewport
svg.selectAll("rect")
    .data(d3.range(x * y))
  .enter().append("rect")
  	.attr("class","pixel")
  	.attr("x", function(d) {
  		return (d%x)*z})
  	.attr("y", function(d) {return Math.floor(d/x)*z})
    //.attr("transform", translate)
    .attr("width", z)
    .attr("height", z)
    .style("fill", function(d) { return d3.hsl(d % x / x * 360, 1, Math.floor(d / x) / y); })
    .on("mouseover", mouseover);

function translate(d) {
  return "translate(" + (d % x) * z + "," + Math.floor(d / x) * z + ")";
}

function mouseover(d) {
  this.parentNode.appendChild(this);
  d3.select(this)
    .attr("x", 0)
    .attr("y", 0)
    .attr("transform", translate)
    
  d3.select(this)
      .style("pointer-events", "none")
    .transition()
      .duration(750)
      //.attr("x", 0)
      //.attr("y", 0)
      .attr("transform", function(d){

      	return "translate(480,480)scale(23)rotate(180)"
      })
      //.attr("width", z*23)
      //.attr("height", z*23)
    .transition()
      .delay(1500)
      .attr("transform", "translate(240,240)scale(0)")
      .style("fill-opacity", 0)
      .remove();
}

function Transform(){
	var rectangles = d3.selectAll(".pixel")[0]
	for (var i = 0; i<QueryManager.querytoggle.length; i++){
		var u = QueryManager.querytoggle[i];
		for (var j = 0; j<QueryManager.layers[u].length; j++){
			QueryManager.layers[u][j][0][0].remove();
		}
		var j = 0;
		var myVar = window.setInterval(function(){
			if (j == rect_query[u].length){
				myStopFunction();
			}
			var k = rect_query[u][j]
			rectangles[k].parentNode.appendChild(rectangles[k]);
			d3.select(rectangles[k])
    			.attr("x", 0)
    			.attr("y", 0)
    			.attr("transform", translate)
    
  			d3.select(rectangles[k])
      			.style("pointer-events", "none")
    			  .transition()
      			.duration(750)
      			.attr("transform", function(d){ return "translate(480,480)scale(23)rotate(180)"})
    			  .transition()
      			.delay(1500)
      			.attr("transform", "translate(240,240)scale(0)")
      			.style("fill-opacity", 0)
      			.remove();	
			j = j + 1;
		}, 500);
		function myStopFunction()
		{
			clearInterval(myVar);
		}
		/*for (var j = 0; j<rect_query[u].length; j++){
		  //var delay=1000//1 seconds
		  var k = rect_query[u][j]
    	  setTimeout(function(){
		  d3.select(rectangles[k])
    		.attr("x", 0)
    		.attr("y", 0)
    		.attr("transform", translate)
    
  		  d3.select(rectangles[k])
      		.style("pointer-events", "none")
    		  .transition()
      		.duration(750)
      		.attr("transform", function(d){ return "translate(480,480)scale(23)rotate(180)"})
    		  .transition()
      		.delay(1500)
      		.attr("transform", "translate(240,240)scale(0)")
      		.style("fill-opacity", 0)
      		.remove();	
			j = j + 1;
    	  },delay)
		  
		
		}*/
		var varsagod = 0;
	}
}

VisDock.eventHandler = {
    getHitsPolygon: function(points, inclusive){
	
		var shapebound = new createPolygon(points);
		//return shapebound.intersectPolygon(d3.selectAll(".pixel")[0], inclusive)
		
		var rectangles = d3.selectAll(".pixel")[0];
		var hits = [];
		if (rect_query[num] == undefined){
			rect_query[num] = [];
			//name_query[num] = [];
		} 
		for (var j=0;j<rectangles.length;j++){
			var captured = shapebound.intersectPolygon([rectangles[j]], inclusive)
			if (captured.length == 1){
				hits.push(captured[0])
				rect_query[num].push(j);
				//name_query[num].push(tree.nodes(treeroot)[j].name)
			}
		}
		
		return hits;

    },
    getHitsEllipse: function(points, inclusive){

		var shapebound = new createEllipse(points);
		var rectangles = d3.selectAll(".pixel")[0];
		var hits = [];
		if (rect_query[num] == undefined){
			rect_query[num] = [];
			//name_query[num] = [];
		} 
		for (var j=0;j<rectangles.length;j++){
			var captured = shapebound.intersectPolygon([rectangles[j]], inclusive)
			if (captured.length == 1){
				hits.push(captured[0])
				rect_query[num].push(j);
				//name_query[num].push(tree.nodes(treeroot)[j].name)
			}
		}
		return hits;

    },
    getHitsLine: function(points, inclusive){

		var shapebound = new createLine(points);
		return shapebound.intersectEllipse(d3.selectAll(".leaf").select("circle")[0], inclusive)

    },
    setColor: function(hits){
		var rectangles = d3.selectAll(".pixel")[0]
		if (rect_query.length != num){
			rect_query[num-1] = []
			//name_query[num-1] = []
			for (var j = 0; j < rectangles.length; j++){
				for (var k = 0; k < hits.length; k++){
					if (hits[k] == circles[j]){
						node_query[num-1].push(j)
						//name_query[num-1].push(tree.nodes(treeroot)[j].name)
					} 
				}
			}
		}
		//VisDock.utils.addPathLayer(hits[i], "fill: " + VisDock.color[num - 1] + "; opacity: 0.8");
		//var CircleElements = d3.selectAll(".leaf").select("circle")[0];
		for (var i=0;i<hits.length;i++){
		    VisDock.utils.addPolygonLayer(hits[i], "fill: " + VisDock.color[num - 1] + "; opacity: 0.8");
		}
    },
    changeColor: function(color, query, index){
	var visibility = VisDock.utils.getQueryVisibility(index);	
		for (var i=0;i<query.length;i++){
		    query[i].attr("style","opacity:" + visibility + ";fill: " +color)
		}
    },
    changeVisibility: function(vis, query, index){
		var color = VisDock.utils.getQueryColor(index);
		for (var i=0;i<query.length;i++){
		    query[i].attr("style","opacity:" + vis + ";fill: " +color)
		}
    },
    removeColor: function(hits, index){
		for (var i=0;i<hits.length;i++){
		    hits[i].remove();
		}
    }
}

</script>
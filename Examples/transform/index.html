<!DOCTYPE html>
<meta charset="utf-8">
<link rel="stylesheet" href="visdock.css">
<title>Transform Transitions</title>
<style>

body {
  margin: 0;
}

.pixel {
  stroke: #fff;
  stroke-width: .1px;
}

#none {
	stroke: #fff;
	stroke-width: .1px;
}

</style>
<body>
<div id = "none">
	<button>Transform</button>
</div>
<!--<div class = "buttons">
	
</div>-->	
<script src="http://d3js.org/d3.v3.min.js"></script>


<script type="text/javascript" src="2D.js"></script>
<script type="text/javascript" src="IntersectionUtilities.js"></script>

<script type="text/javascript" src="visdock.js"></script>
<script type="text/javascript" src="visdock.utils.js"></script>
<script>

var w = 960,
    h = 500,
    z = 20,
    x = w / z,
    y = h / z;
    
VisDock.init("body", 1200, 750);
var viewport = VisDock.getViewport();
//var svg = d3.select("body").append("svg")
//    .attr("width", w)
//    .attr("height", h);
var svg = viewport
svg.selectAll("rect")
	
    .data(d3.range(x * y))
  .enter().append("rect")
  	.attr("class","pixel")
  	.attr("x", function(d) {
  		return (d%x)*z})
  	.attr("y", function(d) {return Math.floor(d/x)*z})
    //.attr("transform", translate)
    .attr("width", z)
    .attr("height", z)
    .style("fill", function(d) { return d3.hsl(d % x / x * 360, 1, Math.floor(d / x) / y); })
    .on("mouseover", mouseover);

function translate(d) {
  return "translate(" + (d % x) * z + "," + Math.floor(d / x) * z + ")";
}

function mouseover(d) {
  this.parentNode.appendChild(this);
  d3.select(this)
    .attr("x", 0)
    .attr("y", 0)
    .attr("transform", translate)
    
  d3.select(this)
      .style("pointer-events", "none")
    .transition()
      .duration(750)
      //.attr("x", 0)
      //.attr("y", 0)
      .attr("transform", function(d){
      	//var dx = 0//-(d%x)*z
      	//var dy = 0//-Math.floor(d/x)*z
      	//return "translate(10,10)scale(2)"
      	//return "translate("+dx.toString()+","+ dy.toString()+")rotate(180)";
      	return "translate(480,480)scale(23)rotate(180)"
      })
      //.attr("width", z*23)
      //.attr("height", z*23)
    .transition()
      .delay(1500)
      
      /*.attr("transform", function(d){
      	var dx = 0//240 - (d%x)*z
      	var dy = 0//240 - Math.floor(d/x)*z
      	return "translate("+dx.toString()+"," + dy.toString()+")scale(0)"
      })*/
      .attr("transform", "translate(240,240)scale(0)")
      .style("fill-opacity", 0)
      .remove();
}

VisDock.eventHandler = {
    getHitsPolygon: function(points, inclusive){
	
		var shapebound = new createPolygon(points);
		return shapebound.intersectPolygon(d3.selectAll(".pixel")[0], inclusive)
		/*var circles = d3.selectAll("rect")[0];
		var hits = [];
		if (node_query[num] == undefined){
			node_query[num] = [];
			name_query[num] = [];
		} 
		for (j=0;j<circles.length;j++){
			var captured = shapebound.intersectEllipse([circles[j]], inclusive)
			if (captured.length == 1){
				hits.push(captured[0])
				node_query[num].push(j);
				name_query[num].push(tree.nodes(treeroot)[j].name)
			}
		}*/
		
		//return hits;

    },
    getHitsEllipse: function(points, inclusive){

		var shapebound = new createEllipse(points);
		return shapebound.intersectPolygon(d3.selectAll(".pixel")[0], inclusive)

    },
    getHitsLine: function(points, inclusive){

		var shapebound = new createLine(points);
		return shapebound.intersectEllipse(d3.selectAll(".leaf").select("circle")[0], inclusive)

    },
    setColor: function(hits){
		/*var circles = d3.selectAll("circle")[0]
		if (node_query.length != num){
			node_query[num-1] = []
			name_query[num-1] = []
			for (var j = 0; j < circles.length; j++){
				for (var k = 0; k < hits.length; k++){
					if (hits[k] == circles[j]){
						node_query[num-1].push(j)
						name_query[num-1].push(tree.nodes(treeroot)[j].name)
					} 
				}
			}
		}*/
		//VisDock.utils.addPathLayer(hits[i], "fill: " + VisDock.color[num - 1] + "; opacity: 0.8");
		//var CircleElements = d3.selectAll(".leaf").select("circle")[0];
		for (var i=0;i<hits.length;i++){
		    VisDock.utils.addPolygonLayer(hits[i], "fill: " + VisDock.color[num - 1] + "; opacity: 0.8");
		}
    },
    changeColor: function(color, query, index){
	var visibility = VisDock.utils.getQueryVisibility(index);	
		for (var i=0;i<query.length;i++){
		    query[i].attr("style","opacity:" + visibility + ";fill: " +color)
		}
    },
    changeVisibility: function(vis, query, index){
		var color = VisDock.utils.getQueryColor(index);
		for (var i=0;i<query.length;i++){
		    query[i].attr("style","opacity:" + vis + ";fill: " +color)
		}
    },
    removeColor: function(hits, index){
		for (var i=0;i<hits.length;i++){
		    hits[i].remove();
		}
    }
}

</script>
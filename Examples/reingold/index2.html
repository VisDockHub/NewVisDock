<!DOCTYPE html>
<meta charset="utf-8">
<link rel="stylesheet" href="visdock.css">
<style>

.node circle {
  fill: #fff;
  stroke: steelblue;
  stroke-width: 1.5px;
}

.node {
  font: 10px sans-serif;
}

.link {
  fill: none;
  stroke: #ccc;
  stroke-width: 1.5px;
}

</style>
<body>
<div class="none">
	<button class="refresh">Refresh</button>
	<button class="merge" onclick="merge();">Merge</button>
	<button class="Delete" onclick="erase();">Delete</button>
	<button class="duplicate" onclick="duplicate();">Duplicate</button>
	<button class="paste" onclick="paste();">Paste</button>
</div>	
<div id="viz" class="none">
	
</div>

<script src="http://d3js.org/d3.v3.min.js"></script>

<script type="text/javascript" src="2D.js"></script>
<script type="text/javascript" src="IntersectionUtilities.js"></script>

<script type="text/javascript" src="visdock.js"></script>
<script type="text/javascript" src="visdock.utils.js"></script>

<script>

var diameter = 960;

var tree = d3.layout.tree()
    .size([360, diameter / 2 - 120])
    .separation(function(a, b) { return (a.parent == b.parent ? 1 : 2) / a.depth; });

var diagonal = d3.svg.diagonal.radial()
    .projection(function(d) { return [d.y, d.x / 180 * Math.PI]; });

VisDock.init("#viz", 1100, 800)
var viewport = VisDock.getViewport();

Panel.x = diameter/2;
Panel.y = diameter/2;
Panel.setTransform();
var svg = viewport;
var treeroot;
var node_query = [];
var name_query = [];
var duplicated = [];
/*var svg = d3.select("body").append("svg")
    .attr("width", diameter)
    .attr("height", diameter - 150)
  .append("g")
    .attr("transform", "translate(" + diameter / 2 + "," + diameter / 2 + ")");
*/

d3.json("reingold.json", function(error, root) {
  treeroot = root;
  var nodes = tree.nodes(root),
      links = tree.links(nodes);

  var link = svg.selectAll(".link")
      .data(links)
    .enter().append("path")
      .attr("class", "link")
      .attr("d", diagonal);

  var node = svg.selectAll(".node")
      .data(nodes)
    .enter().append("g")
      .attr("class", "Node")
      .attr("transform", function(d) { return "rotate(" + (d.x - 90) + ")translate(" + d.y + ")"; })

  var node2 = svg.selectAll(".nodes")
      .data(nodes)
    .enter().append("g")
      .attr("class", "node")

  node2.append("circle")
  	  .attr("cx", function(d){
  	  	return Math.cos((d.x-90)/180*Math.PI)*d.y
  	  	})
  	  .attr("cy", function(d){
  	  	return Math.sin((d.x-90)/180*Math.PI)*d.y
  	  	})
      .attr("r", 4.5);

  node.append("text")
      .attr("dy", ".31em")
      .attr("text-anchor", function(d) { return d.x < 180 ? "start" : "end"; })
      .attr("transform", function(d) { return d.x < 180 ? "translate(8)" : "rotate(180)translate(-8)"; })
      .text(function(d) { return d.name; });
});

d3.select(self.frameElement).style("height", diameter - 150 + "px");


VisDock.eventHandler = {
    getHitsPolygon: function(points, inclusive){
	
		var shapebound = new createPolygon(points);
		var circles = d3.selectAll("circle")[0];
		var hits = [];
		if (node_query[num] == undefined){
			node_query[num] = [];
			name_query[num] = [];
		} 
		for (j=0;j<circles.length;j++){
			var captured = shapebound.intersectEllipse([circles[j]], inclusive)
			if (captured.length == 1){
				hits.push(captured[0])
				node_query[num].push(j);
				name_query[num].push(tree.nodes(treeroot)[j].name)
			}
		}
		
		return hits;
		//return shapebound.intersectEllipse(d3.selectAll("circle")[0], inclusive)

    },
    getHitsEllipse: function(points, inclusive){

		var shapebound = new createEllipse(points);
		return shapebound.intersectEllipse(d3.selectAll(".leaf").select("circle")[0], inclusive)

    },
    getHitsLine: function(points, inclusive){

		var shapebound = new createLine(points);
		return shapebound.intersectEllipse(d3.selectAll(".leaf").select("circle")[0], inclusive)

    },
    setColor: function(hits){
		var circles = d3.selectAll("circle")[0]
		if (node_query.length != num){
			node_query[num-1] = []
			name_query[num-1] = []
			for (var j = 0; j < circles.length; j++){
				for (var k = 0; k < hits.length; k++){
					if (hits[k] == circles[j]){
						node_query[num-1].push(j)
						name_query[num-1].push(tree.nodes(treeroot)[j].name)
					} 
				}
			}
		}
		
		var CircleElements = d3.selectAll(".leaf").select("circle")[0];
		for (var i=0;i<hits.length;i++){
		    VisDock.utils.addEllipseLayer(hits[i]);
		}
    },
    changeColor: function(color, query, index){
	var visibility = VisDock.utils.getQueryVisibility(index);	
		for (var i=0;i<query.length;i++){
		    query[i].attr("style","opacity:" + visibility + ";fill: " +color)
		}
    },
    changeVisibility: function(vis, query, index){
		var color = VisDock.utils.getQueryColor(index);
		for (var i=0;i<query.length;i++){
		    query[i].attr("style","opacity:" + vis + ";fill: " +color)
		}
    },
    removeColor: function(hits, index){
		for (var i=0;i<hits.length;i++){
		    hits[i].remove();
		}
    }
}



function erase(){
	var k = treeroot.children.length;
	var total_nodes = tree.nodes(treeroot)
	for (var j = 0; j < QueryManager.querytoggle.length; j++){
		var u = QueryManager.querytoggle[j]
		for (var i = 0;i < node_query[u].length; i++){
			var element = total_nodes[node_query[u][i]].name
			erase_node(treeroot, element)
		}
		VisDock.eventHandler.removeColor(QueryManager.layers[u], u)
	}
	refresh();
}

function erase_node(Node, element){
	if (Node.children == undefined){
		if (Node.name == element){
			var n = Node.parent.children.indexOf(Node)
			Node.parent.children.splice(n,1)
			return 1;
		}
		return 0;
	}else{
		if (Node.name == element){
			var n = Node.parent.children.indexOf(Node)
			Node.parent.children.splice(n,1)
			return 1;
		} else{
			var m = Node.children.length;
			
			for (var j = 0; j < m; j++){
				var erased = erase_node(Node.children[j], element)
				if (erased == 1) return 1;
			}
			return 0;
		}		
	}
}

function merge(){
	var k = treeroot.children.length;
	var total_nodes = tree.nodes(treeroot)
	var enfants = [];
	var names = [];
	for (var j = 0; j < QueryManager.querytoggle.length; j++){
		var u = QueryManager.querytoggle[j]
		names[j] = [];
		for (var i = 0;i < node_query[u].length; i++){
			var element = total_nodes[node_query[u][i]].name
			if (i < node_query[u].length-1){
				enfants.push(merge_search(treeroot, element))
			}else{
				names[j] = element
				for (var k = 0; k < enfants.length; k++){
					if (enfants[k].length != 1){
						searchNpaste(treeroot, element, enfants[k])
					}
				}
			}
			
		}
		for (var i=0;i<QueryManager.layers[u].length-1;i++){
			//QueryManager.layers[u].splice(i,1);
		    QueryManager.layers[u][i].remove();
		}		
		//VisDock.eventHandler.removeColor(QueryManager.layers[u], u)
	}
	
	
	refresh();

}

function merge_search(Node, element){
	if (Node.children == undefined){
		if (Node.name == element){
			var n = Node.parent.children.indexOf(Node)
			Node.parent.children.splice(n,1)
			return [1];
		}
		return [];
	}else{
		if (Node.name == element){
			var n = Node.parent.children.indexOf(Node)
			var array1 = Node.children;
			Node.parent.children.splice(n,1)
			return array1;
		} else{
			var m = Node.children.length;
			
			for (var j = 0; j < m; j++){
				var erased = merge_search(Node.children[j], element)
				if (erased.length >= 1) return erased;
			}
			return [];
		}		
	}	
}

function searchNpaste(Node, element, children){
	if (Node.children == undefined){
		if (Node.name == element){
			Node.children = children
			//var n = Node.parent.children.indexOf(Node)
			//Node.parent.children.splice(n,1)
			return 1;
		}
		return [];
	}else{
		if (Node.name == element){
			Node.children = Node.children.concat(children)
			//var n = Node.parent.children.indexOf(Node)
			//var array1 = Node.children;
			//Node.parent.children.splice(n,1)
			//return array1;
			return 1;
		} else{
			var m = Node.children.length;
			
			for (var j = 0; j < m; j++){
				var erased = searchNpaste(Node.children[j], element, children)
				if (erased == 1) return 1;
			}
			return 0;
			//return 0;
		}		
	}	
}

function searchNpaste(Node, element, children){
	if (Node.children == undefined){
		if (Node.name == element){
			Node.children = children
			//var n = Node.parent.children.indexOf(Node)
			//Node.parent.children.splice(n,1)
			return 1;
		}
		return [];
	}else{
		if (Node.name == element){
			Node.children = Node.children.concat(children)
			//var n = Node.parent.children.indexOf(Node)
			//var array1 = Node.children;
			//Node.parent.children.splice(n,1)
			//return array1;
			return 1;
		} else{
			var m = Node.children.length;
			
			for (var j = 0; j < m; j++){
				var erased = searchNpaste(Node.children[j], element, children)
				if (erased == 1) return 1;
			}
			return 0;
			//return 0;
		}		
	}	
}

function duplicate(){
	var k = treeroot.children.length;
	var total_nodes = tree.nodes(treeroot)	
	for (var j = 0; j < QueryManager.querytoggle.length; j++){
		var u = QueryManager.querytoggle[j]
		for (var i = 0; i < node_query[u].length; i++){
			duplicated.push(total_nodes[node_query[u][i]])
		}
	}
}

function paste(){
	var total_tree = tree.nodes(treeroot) 
	if (QueryManager.querytoggle.length != 1){
		alert("Please choose only one query")
	} else {
		var u = QueryManager.querytoggle[0];
		if (node_query[u].length != 1){
			alert("Please select only one node")
		} else {
			var element = total_tree[node_query[u][0]].name
			searchNpaste(treeroot, element, duplicated)
		}
	}
	refresh();
}

//function searchNpaste(){
	
//}

function refresh(){

  svg.selectAll("text").remove();
  svg.selectAll("circle").remove();
  svg.selectAll(".node").remove();	
  svg.selectAll(".Node").remove();	
  svg.selectAll("path").remove();	
  var nodes = tree.nodes(treeroot),
      links = tree.links(nodes);
	
  var link = svg.selectAll(".link")
      .data(links)
    .enter().append("path")
      .attr("class", "link")
      .attr("d", diagonal);

  var node = svg.selectAll(".node")
      .data(nodes)
    .enter().append("g")
      .attr("class", "Node")
      .attr("transform", function(d) { return "rotate(" + (d.x - 90) + ")translate(" + d.y + ")"; })

  var node2 = svg.selectAll(".nodes")
      .data(nodes)
    .enter().append("g")
      .attr("class", "node")

  node2.append("circle")
  	  .attr("cx", function(d){
  	  	return Math.cos((d.x-90)/180*Math.PI)*d.y
  	  	})
  	  .attr("cy", function(d){
  	  	return Math.sin((d.x-90)/180*Math.PI)*d.y
  	  	})
      .attr("r", 4.5);

  node.append("text")
      .attr("dy", ".31em")
      .attr("text-anchor", function(d) { return d.x < 180 ? "start" : "end"; })
      .attr("transform", function(d) { return d.x < 180 ? "translate(8)" : "rotate(180)translate(-8)"; })
      .text(function(d) { return d.name; });	
	var total_nodes = tree.nodes(treeroot)
	for (var i = 0; i < QueryManager.layers.length; i++){
		for (var k = 0; k < QueryManager.layers[i].length; k++){
			var ux = uy = -200;
			for (var j = 0; j < total_nodes.length; j++){
				if (total_nodes[j].name == name_query[i][k]){
					//var u = QueryManager.querytoggle[i]
					//var n = QueryManager.layers[u].length-1;
					ux = total_nodes[j].x
					uy = total_nodes[j].y
				}
			}
			if (ux != -200 && uy != -200){
				var x = Math.cos((ux-90)/180*Math.PI)*uy
				var y = Math.sin((ux-90)/180*Math.PI)*uy
				QueryManager.layers[i][k][0][0].setAttributeNS(null,"cx", x)
				QueryManager.layers[i][k][0][0].setAttributeNS(null,"cy", y)
			}
		}
	}

}

</script>

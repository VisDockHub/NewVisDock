<!DOCTYPE html>
<meta charset="utf-8">
<link href="visdock.css" rel="stylesheet" type="text/css"/>
<style>
	.states {
		fill: none;
		stroke: #fff;
		stroke-linejoin: round;
	}

	.q0-9 {
		fill: rgb(247,251,255);
	}
	.q1-9 {
		fill: rgb(222,235,247);
	}
	.q2-9 {
		fill: rgb(198,219,239);
	}
	.q3-9 {
		fill: rgb(158,202,225);
	}
	.q4-9 {
		fill: rgb(107,174,214);
	}
	.q5-9 {
		fill: rgb(66,146,198);
	}
	.q6-9 {
		fill: rgb(33,113,181);
	}
	.q7-9 {
		fill: rgb(8,81,156);
	}
	.q8-9 {
		fill: rgb(8,48,107);
	}

</style>
<body>
	<script src="http://d3js.org/d3.v3.min.js"></script>
	<script src="http://d3js.org/queue.v1.min.js"></script>
	<script src="http://d3js.org/topojson.v0.min.js"></script>
	<script type="text/javascript" src="visdock.js"></script>
	<script type="text/javascript" src="2D.js"></script>
	<script src="IntersectionUtilities.js"></script>
	<script src="visdock.utils.js"></script>

	<script>
		width = 1100;
		height = 700;

		VisDock.init("body", width, height);
		VisDock.SelectShape = "circle"
		VisDock.opacity = 0.8;

		// Get the VisDock viewport
		var viewport = VisDock.getViewport();
		viewport.attr("class", "chart");

		var c = 0;
		var mouseclick = 0;
		var rts = [];
		VisDock.eventHandler = {
			getHitsPolygon : function(points, inclusive) {
				var xx = [];
				var yy = [];
				for (var i = 0; i < points.length; i++) {
					xx[i] = points[i][0];
					yy[i] = points[i][1];
				}

				var xmax = Math.max.apply(null, xx)
				var xmin = Math.min.apply(null, xx)
				var ymax = Math.max.apply(null, yy)
				var ymin = Math.min.apply(null, yy)

				var paths = d3.selectAll("path")[0];
				var nElements = paths.length;
				var hits = [];
				var count = 0;
				var captured = 0;
				
				var shapebound = new createPolygon(points);
				rts[num] = [];

				for (var i = 0; i < nElements; i++) {

					var str = paths[i].getAttributeNS(null, "d").split("L")
					var str2 = str[0].split(",");
					var x = str2[0].split("M")[1];
					var y = str2[1];

					captured = 0;
					if (x >= xmin && x <= xmax && y >= ymin && y <= ymax) {

						captured = shapebound.intersectPath(paths[i], inclusive);
					}
					if (captured == 1) {
						var cl = paths[i].getAttributeNS(null,"class").split("-")[0];
						var r = cl.split("q")[1];
						rts[num][count] = parseInt(r);

						hits[count] = i;
						count++;
					}

				}
				//alert(rts[0])
				return hits;
			},
			getHitsLine : function(points, inclusive) {

				var xx = [];
				var yy = [];
				for (var i = 0; i < points.length; i++) {
					xx[i] = points[i][0];
					yy[i] = points[i][1];
				}

				var xmax = Math.max.apply(null, xx)
				var xmin = Math.min.apply(null, xx)
				var ymax = Math.max.apply(null, yy)
				var ymin = Math.min.apply(null, yy)

				var paths = d3.selectAll("path")[0];
				var nElements = paths.length;
				var hits = [];
				var count = 0;
				var captured = 0;
				rts[num] = [];
				var shapebound = new createLine(points)
				for (var i = 0; i < nElements; i++) {

					var str = paths[i].getAttributeNS(null, "d").split("L")
					var str2 = str[0].split(",");
					var x = str2[0].split("M")[1];
					var y = str2[1];

					captured = 0;

					if (x >= xmin && x <= xmax && y >= ymin && y <= ymax) {
						captured = shapebound.intersectPath(paths[i], inclusive);
					}
					//alert("SDJFKL");
					if (captured == 1) {
						var cl = paths[i].getAttributeNS(null,"class").split("-")[0];
						var r = cl.split("q")[1];
						rts[num][count] = parseInt(r);
						hits[count] = i;
						count++;
					}
				}
				return hits;
			},
			getHitsEllipse : function(points, inclusive) {

				var xmax = points[0] + points[2];
				//Math.max.apply(null,xx)
				var xmin = points[0] - points[2];
				//Math.min.apply(null,xx)
				var ymax = points[1] + points[3];
				//Math.max.apply(null,yy)
				var ymin = points[1] - points[3];
				//Math.min.apply(null,yy)

				var paths = d3.selectAll("path")[0];
				var nElements = paths.length;
				//var aa2 = getNodes(nElements);

				var hits = [];
				var count = 0;
				var captured = 0;
				var shapebound = new createEllipse(points);
				rts[num] = [];
				//var shapebound = PolygonInit(points);;
				for (var i = 0; i < nElements; i++) {

					var str = paths[i].getAttributeNS(null, "d").split("L")
					var str2 = str[0].split(",");
					var x = str2[0].split("M")[1];
					var y = str2[1];

					captured = 0;
					//alert("here " + ellipse);
					if (x >= xmin && x <= xmax && y >= ymin && y <= ymax) {//alert(aa[i].getAttributeNS(null,"externalResourcesRequired"))
						if (paths[i].getAttributeNS(null, "id") == "mini") {"dont"
						}
						captured = shapebound.intersectPath(paths[i], inclusive);
						//alert(aa[i])
					}

					if (captured == 1) {
						var cl = paths[i].getAttributeNS(null,"class").split("-")[0];
						var rs = cl.split("q")[1];
						rts[num][count] = parseInt(rs);
						//alert(rts)
						hits[count] = i;
						count++;
					}
				}

				return hits;
			},
			setColor : function(hits) {
				var paths = d3.selectAll("path")[0];
				for (var i=0;i<hits.length;i++){
	    			VisDock.utils.addPathLayer(paths[hits[i]], 
	    				"fill: " + VisDock.color[num - 1] + "; opacity: 0.5");
				}
			},
			changeColor : function(color, query, index) {
    			var vis = VisDock.utils.getQueryVisibility(index);
				for (var i=0;i<query.length;i++){
	    			query[i][0][0].setAttributeNS(null, "style", "fill: " + color + "; opacity: " + vis)
				}
			},
			changeVisibility : function(vis, query, index) {
    			var color = VisDock.utils.getQueryColor(index);
				for (var i=0;i<query.length;i++){
	    			query[i][0][0].setAttributeNS(null, "style", "fill: " + color + "; opacity: " + vis)
				}
			},
			removeColor : function(hits, index) {
				for (var i = 0; i < hits.length; i++) {
					//alert(hits[i])
					hits[i].remove();
				}
			},
			QueryClick : function(query, index) {
				/*	var data = rts[index];
				var movex = mouseclick*225+50;
				var margin = 25;
				var bw = (200-margin*2)/data.length;
				var ymax = Math.max.apply(null,data)
				var minigraph = viewport.append("g")
				.attr("transform","translate("+movex+",500)")

				minigraph.append("rect")
				.attr("width",200).attr("height",200)
				.attr("stroke","black")
				.attr("fill","white")

				for (var i=0;i<data.length;i++){
				var h = (200-margin*2)*data[i]/ymax;
				var movey = margin+(200-margin*2-h);
				minigraph.append("rect")
				.attr("width", bw)
				.attr("height", h)
				.attr("x",(margin+i*bw))
				.attr("y",movey)
				.attr("stroke","black")
				.attr("fill",QueryManager.colors[index]);
				}

				mouseclick++; */
				//alert("bY")
			}
		}

		var width = 960, height = 500;

		var quantize = d3.scale.quantize().domain([0, .15]).range(d3.range(9).map(function(i) {
			return "q" + i + "-9";
		}));

		var path = d3.geo.path();

		//alert("hi");
		var txtFile = new XMLHttpRequest();
		txtFile.open('GET', 'sources2.txt', false);
		//alert("hi2");
		txtFile.onreadystatechange = function() {
			allText = txtFile.responseText;
			allTextLines = txtFile.responseText.split("\r\n");
		}
		txtFile.send();
		var id = [];
		var rates = [];
		for (var i = 0; i < allTextLines.length - 1; i++) {

			var subline = allTextLines[i].split("\t");
			id[i] = subline[0];
			rates[i] = subline[1];
			//alert(subline[1])
		}

		queue().defer(d3.json, "us.json").defer(d3.tsv, "unemployment.tsv").await(ready);

		function ready(error, us, unemployment) {

			var rateById = {};
			for (var i = 0; i < rates.length; i++) {
				rateById[id[i]] = rates[i];
			}

			var svgobj = viewport.append("g").attr("id", "counties").attr("externalResourcesRequired", true).selectAll("path").data(topojson.object(us, us.objects.counties).geometries).enter().append("path").attr("class", function(d) {
				return quantize(rateById[d.id]);
			}).attr("d", path);

			var h = width / height * dockWidth;
			var ratio = dockWidth / width;

		}

	</script>

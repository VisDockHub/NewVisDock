<!DOCTYPE html>
<meta charset="utf-8">
<link rel="stylesheet" href="visdock.css">
<style>
	body {
		font: 10px sans-serif;
	}

	.axis path, .axis line {
		fill: none;
		stroke: #000;
		shape-rendering: crispEdges;
	}

	.bar {
		fill: steelblue;
	}

	.x.axis path {
		display: none;
	}

</style>
<body>
	<script src="http://d3js.org/d3.v3.min.js"></script>

	<script type="text/javascript" src="2D.js"></script>
	<script type="text/javascript" src="IntersectionUtilities.js"></script>

	<script type="text/javascript" src="visdock.js"></script>
	<script type="text/javascript" src="visdock.utils.js"></script>

	<script>
		VisDock.init("body", 1200, 1000)
		var viewport = VisDock.getViewport();

		var margin = {
			top : 20,
			right : 20,
			bottom : 30,
			left : 40
		}, width = 960 - margin.left - margin.right, height = 500 - margin.top - margin.bottom;

		var x = d3.scale.ordinal().rangeRoundBands([0, width], .1);

		var y = d3.scale.linear().rangeRound([height, 0]);

		var color = d3.scale.ordinal().range(["#98abc5", "#8a89a6", "#7b6888", "#6b486b", "#a05d56", "#d0743c", "#ff8c00"]);

		var xAxis = d3.svg.axis().scale(x).orient("bottom");

		var yAxis = d3.svg.axis().scale(y).orient("left").tickFormat(d3.format(".2s"));

		//var svg = d3.select("body").append("svg")
		//    .attr("width", width + margin.left + margin.right)
		//    .attr("height", height + margin.top + margin.bottom)
		//  .append("g")
		//    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

		var svg = viewport;
		Panel.x = margin.left;
		Panel.y = margin.top;
		Panel.setTransform();

		d3.csv("data.csv", function(error, data) {
			color.domain(d3.keys(data[0]).filter(function(key) {
				return key !== "State";
			}));

			data.forEach(function(d) {
				var y0 = 0;
				d.ages = color.domain().map(function(name) {
					return {
						name : name,
						y0 : y0,
						y1 : y0 += +d[name]
					};
				});
				d.total = d.ages[d.ages.length - 1].y1;
			});

			data.sort(function(a, b) {
				return b.total - a.total;
			});

			x.domain(data.map(function(d) {
				return d.State;
			}));
			y.domain([0, d3.max(data, function(d) {
				return d.total;
			})]);

			svg.append("g").attr("class", "x axis").attr("transform", "translate(0," + height + ")").call(xAxis);

			svg.append("g").attr("class", "y axis").call(yAxis).append("text").attr("transform", "rotate(-90)").attr("y", 6).attr("dy", ".71em").style("text-anchor", "end").text("Population");

			var state = svg.selectAll(".state").data(data).enter().append("g").attr("class", "g").attr("transform", function(d) {
				//alert(x(d.State))
				//return x(d.State)
				return "translate(" + x(d.State) + ",0)";
			});

	state.selectAll("rect")
      .data(function(d) { 
      	return d.ages; })
    .enter().append("rect")
      .attr("width", x.rangeBand())
      .attr("id", function(d){
      	var str = this.parentElement.getAttributeNS(null, "transform").split("(")[1]
      	var x_1 = str.split(",")[0]
      	var id = x_1 + "," + y(d.y1) + " " + (parseFloat(x_1) + x.rangeBand()) + "," + y(d.y1) + 
      			" " + (parseFloat(x_1) + x.rangeBand()) + "," + (y(d.y0)) + " " + x_1 + "," + y(d.y0);
      	return id;
      	//alert(id)  
      })
      .attr("class", "stackbar")
      .attr("y", function(d) { return y(d.y1); })
      .attr("height", function(d) { return y(d.y0) - y(d.y1); })
      .style("fill", function(d) { return color(d.name); });

			var legend = svg.selectAll(".legend").data(color.domain().slice().reverse()).enter().append("g").attr("class", "legend").attr("transform", function(d, i) {
				return "translate(0," + i * 20 + ")";
			});

			legend.append("rect").attr("x", width - 18).attr("width", 18).attr("height", 18).style("fill", color);

			legend.append("text").attr("x", width - 24).attr("y", 9).attr("dy", ".35em").style("text-anchor", "end").text(function(d) {
				return d;
			});

		});

		VisDock.selectionHandler = {
			getHitsPolygon : function(points, inclusive) {
				var circleObjects = d3.selectAll(".stackbar")[0];
				var nElements = circleObjects.length
				
				var hits = [];
				var count = 0;
				var captured = 0;

				// shapebound is a new polygon object for the polygon created by using selection tools.
				var shapebound = new createPolygon(points);
				for (var i = 0; i < nElements; i++) {
					var newpoly = document.createElementNS("http://www.w3.org/2000/svg","polygon");
					var points2 = circleObjects[i].getAttributeNS(null, "id")
					newpoly.setAttributeNS(null, "points", points2)
					newpoly.setAttributeNS(null, "transform", "translate(" + [Panel.x,Panel.y]+")")		
					captured = shapebound.intersectPolygon(newpoly, inclusive);
					// captured will have 0 if the path element 'pathOjbect[i]' and the shapebound do not
					// intersect
					// Otherwise, it will have 1
					if (captured == 1) {
						// we are storing the index of the path object. But the users may
						//  choose to store other information or the object itself.
						hits[count] = i;
						count++;
					}
				}
				return hits;

			},

			getHitsEllipse : function(points, inclusive) {
				var circleObjects = d3.selectAll(".stackbar")[0];
				var nElements = circleObjects.length
				
				var hits = [];
				var count = 0;
				var captured = 0;

				// shapebound is a new polygon object for the polygon created by using selection tools.
				var shapebound = new createEllipse(points);
				for (var i = 0; i < nElements; i++) {
					var newpoly = document.createElementNS("http://www.w3.org/2000/svg","polygon");
					var points2 = circleObjects[i].getAttributeNS(null, "id")
					newpoly.setAttributeNS(null, "points", points2)
					newpoly.setAttributeNS(null, "transform", "translate(" + [Panel.x,Panel.y]+")")		
					captured = shapebound.intersectPolygon(newpoly, inclusive);
					// captured will have 0 if the path element 'pathOjbect[i]' and the shapebound do not
					// intersect
					// Otherwise, it will have 1
					if (captured == 1) {
						// we are storing the index of the path object. But the users may
						//  choose to store other information or the object itself.
						hits[count] = i;
						count++;
					}
				}
				return hits;
			},

			getHitsLine : function(points, inclusive) {
				var circleObjects = d3.selectAll(".stackbar")[0];
				var nElements = circleObjects.length
				
				var hits = [];
				var count = 0;
				var captured = 0;

				// shapebound is a new polygon object for the polygon created by using selection tools.
				var shapebound = new createLine(points);
				for (var i = 0; i < nElements; i++) {
					var newpoly = document.createElementNS("http://www.w3.org/2000/svg","polygon");
					var points2 = circleObjects[i].getAttributeNS(null, "id")
					newpoly.setAttributeNS(null, "points", points2)
					newpoly.setAttributeNS(null, "transform", "translate(" + [Panel.x,Panel.y]+")")		
					captured = shapebound.intersectPolygon(newpoly, inclusive);
					// captured will have 0 if the path element 'pathOjbect[i]' and the shapebound do not
					// intersect
					// Otherwise, it will have 1
					if (captured == 1) {
						// we are storing the index of the path object. But the users may
						//  choose to store other information or the object itself.
						hits[count] = i;
						count++;
					}
				}
				return hits;
			},

			setColor : function(hits) {
				
				var circleObjects = d3.selectAll(".stackbar")[0];
				var sum = 0;
				for (var i = 0; i < hits.length; i++) {
					var newpoly = document.createElementNS("http://www.w3.org/2000/svg","polygon");
					var points2 = circleObjects[hits[i]].getAttributeNS(null, "id")
					newpoly.setAttributeNS(null, "points", points2)
					//newpoly.setAttributeNS(null, "transform", "translate(" + [Panel.x,Panel.y]+")")		
					var y0 = circleObjects[hits[i]].__data__.y0;
					var y1 = circleObjects[hits[i]].__data__.y1;
					sum += (y1-y0)
					VisDock.utils.addPolygonLayer(newpoly);
				}
				alert("Total queried: " + sum)
			},
			changeColor : function(color, query, index) {
				VisDock.utils.changeQueryColor(index, color)
				var visibility = VisDock.utils.getQueryVisibility(index);
				for (var i = 0; i < query.length; i++) {
					query[i].attr("style", "opacity: " + visibility + "; fill: " + color)
				}
			},

			changeVisibility : function(vis, query, index) {
				var color = VisDock.utils.getQueryColor(index);
				for (var i = 0; i < query.length; i++) {
					query[i].attr("style", "opacity: " + vis + "; fill: " + color)
				}
			},

			removeColor : function(hits, index) {
				for (var i = 0; i < hits.length; i++) {
					hits[i].remove();
				}
			},
		}

	</script>
